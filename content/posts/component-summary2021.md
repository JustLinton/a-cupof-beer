---
title: 计算机组成与设计2021年总结
date: 2021-06-26 17:13:06
tags: [计算机组成原理]



---



## 计算机组成原理考点

#### 小题

根据国标规定，汉字占2B。

小题
根据国标规在虚存中，地址映射由？完成。

存储单元是什么？

虚存的作用？

汉字的编码：输入码（外码）用于汉字输入，机内码（内码）用于内部处理，输出码（字型码）

冯计算机结构，流水线

#### 计算

| 章节   | 题目                                                         |
| ------ | ------------------------------------------------------------ |
| 机器数 | 补码加减法，原码一位乘，补码一位乘，原码一位除（不恢复余数），溢出判断，规格化，原移码转换，原反补转换，进制转换，浮点数转真值，IEEE 754 |
| 存储器 | Cache命中率，利用率和平均访问时间，DMA和中断方式访存效率。主存地址在Cache中的位置映射。 |
| 其他   | CPI和主频                                                    |

###### 原码一位乘法注意

- 硬件配置：部分积在ACC累加器中，乘数在MQ移位寄存器中，被乘数在公共寄存器X中。最终ACC保存高位结果，MQ保存低位结果。
- 可以用分隔符标明原来MQ寄存器内的内容。当MQ中原内容全部被移出，机器立刻停机。
- 第一次操作不移位，最后一次操作只移位。
- 一开始，ACC是0，每次如果MQ最低位是1则ACC加X的内容。
- 由于原码，所以需要自己判断符号。具体做法是最后异或。
- ACC保存小数，MQ保存整数。
- 由于是原码，小数采用一位符号位，且采用逻辑移位（因为符号位不参与运算。补码是参与运算的，也就因此可以自动生成符号（补码的作用就是把符号也实现运算的封闭性））
- 1位符号位的作用是兜进位。
- 为了加速，可以不+0，而是碰到要+0就直接逻辑移位。
- 每次加的时候，看着X寄存器加。

###### 补码校正乘法注意

补码校正法和原码一位乘法的区别（除了这三条，其余当作原码一位乘法计算）：

- ACC和X采用双符号位；
- 算术移位；
- 最后可能要校正（ACC要加X寄存器内的反补码）；

如果符号不相同，让负的那个作被乘数（即X寄存器），这样不需要校正。

###### Booth算法和校正法的区别

- 最后一次移位后不管怎样都要加
- MQ寄存器多了最高的“符号位”和最低的“附加位”
- 每次加的数由原来的X补、0变成了X补、X反补、0.

| 算法         | 加法次数和移位次数的关系                         |
| ------------ | ------------------------------------------------ |
| 原码一位乘法 | 最后移位后一定不需要加法了                       |
| 校正法       | 最后移位后如果需要校正还需要加X的反补码          |
| Booth算法    | 最后移位后必然需要加法，加X的反补码，X的补码或+0 |

###### Booth法的MQ的写法

一开始可以写成例如0//1001//0的形式，左边0是符号位，右边0是附加位。然后，右边的“//”不管怎么移位都定住不动，左边的“//”随着移位去动。**当两个“//”重合了**，就完成了所有移位操作。

#### 简答

| 章节          | 题目                                                         |
| ------------- | ------------------------------------------------------------ |
| IO方式        | 3种IO方式，IO中断过程（包括多重），DMA和周期挪用，中断隐指令，比较DMA和中断方式，**中断屏蔽字**，中断响应（顺序）和其条件 |
| CPU和机器指令 | 三种周期（指令，时钟，机器），CISK和RISK，计算机如何区分指令和数据，微程序指令入口地址的形成，扩展操作码，微程序和微操作和机器指令的关系，组合逻辑和微程序设计的比较，**指令集设计应当考虑的因素**，CPU的功能，指令流水 |
| 存储器        | 单管RAM的工作原理，集中刷新分散刷新，DRAM和SRAM区别，CPU某些寄存器作用，寻址方式（变址寻址，存储器寻址，间接寻址），Cache如何访存，多层次存储的好处，如何提高访存速度，交叉存储，存储对齐，Cache替换算法，设计Cache映射 |
| 机器数        | ALU概念，超前进位的理念,**Booth算法的运算器结构**            |

#### 分析设计

| 章节              | 题目                                                         |
| ----------------- | ------------------------------------------------------------ |
| CPU，指令和微程序 | 指令格式，写各个周期指令，写ADD、SUB指令的微程序，指令设计（例题：扩展操作码），设计微指令（例题），设计时序系统 |
| 存储器            | 存储器扩展，Cache组相联地址设计，虚存                        |
| 数字逻辑          | 卡诺图F（0，2，4，8，...），并由卡诺图画出逻辑电路           |

###### 冯诺伊曼计算机的特点是什么？

| M1           | M2                                                           |
| ------------ | ------------------------------------------------------------ |
| 五大组成部分 | 运算器，控制器，存储器，输入设备，输出设备构成；以运算器为中心 |
| 指令的存储   | 指令和数据同等地位存储，可用地址寻址                         |
| 指令的表示   | 由操作码和地址码组成；二进制表示                             |
| 程序的表示   | 程序顺序存储在存储器内，通常自动顺序取出                     |

###### 结合框图说明现代计算机的硬件组成？

| M1           | M2                                                           |
| ------------ | ------------------------------------------------------------ |
| 三大组成部分 | CPU，主存，IO设备；其中，CPU和主存合称主机，IO设备又称外设。 |
| CPU的作用    | ALU完成各种算术逻辑运算；CU解释指令并发出操作命令，执行之。  |
| 主存的作用   | 存放程序和数据，直接与CPU交换信息。                          |
| IO设备       | 受CPU的控制，完成各种IO操作。                                |

###### 说明CPU某些寄存器作用

MAR、MDR、ALU中的累加器ACC，乘商寄存器MQ，操作数寄存器X，变址寄存器IX，基址寄存器BR，CU中的程序计数器PC，指令寄存器IR。

###### 计算机是怎样区分指令和数据的

1. 通过不同的时间段来区分指令和数据，即在取指令阶段（或取指微程序）取出的为指令，在执行指令阶段（或相应微程序）取出的即为数据。
2. 通过地址来源区分，由PC提供存储单元地址的取出的是指令，由指令地址码部分提供存储单元地址的取出的是操作数。
3. 通过取出后放置的位置区分：取来的机器指令应存放在指令寄存器，而取来的数据（或操作数）则应该存放在以累加器为代表的通用寄存器内。

###### 说明海明码的原理？

海明码是对**多个数据位使用多个校验位**的纠错码编码方案。

对每个校验位采用**偶校验**计算其值，把**每个**数据位分配到**不同**的校验位的计算中去。

如果某一位出错，则**引起与之相关的若干**校验位变化。这样就能直接看出是哪一位错了，起到纠错的效果。

```
2^r>=k+r+1.
```

###### 为什么IEEE 754中采用移码表示阶码？

因为有助于简化判零线路。利于判机器0.

###### 定点运算器的组成？为什么要使用MQ寄存器？

组成：ALU、通用寄存器、MQ寄存器、多路选择器、输入输出逻辑电路。

MQ功能：

| 过程   | 乘法     | 除法       |
| ------ | -------- | ---------- |
| 运算前 | 乘数     | 被除数低位 |
| 运算后 | 结果低位 | 结果       |

###### 为什么要用DMA，周期挪用的原理

为了进一步提高CPU的资源利用率，使I/O设备直接与内存交换信息，所以用DMA方式。当CPU和I/O设备同时访问主存时，CPU总是将总线占有权让给DMA一个存取周期，叫做周期挪用。

###### 说明微指令和微操作、微程序和机器指令、微程序和程序之间的关系。

1. 微操作是指由微命令控制实现的最基本操作，微指令是微操作控制信号代码化的结果，一条微指令对应着一个或几个微操作命令（即微命令）。
2. 微程序是一系列微指令的有序集合。在微程序控制的计算机中，一条机器指令的功能通常是由一段微程序完成的。微程序存放在控存中，而机器指令属于机器的指令集，由机器指令构成的程序存放在内存中。
3. 微程序是由计算机的设计人员编写的，存放在控制存储器中，只能读出，不能修改。而程序是一系列机器指令的有序集合，用于解决实际问题，可由普通程序员编写，存放在主存中，可以更新修改。

###### 存储器的结构层次体现？为什么要分这些层？计算机如何管理它们？

| M1             | M2                                                           |
| -------------- | ------------------------------------------------------------ |
| 二级层次划分   | Cache-主存、主存-辅存                                        |
| Cache-主存作用 | 速度问题。                                                   |
| 主存-辅存作用  | 容量问题。                                                   |
| 管理调度       | Cache-主存的调度通过硬件完成；主存-辅存的调度通过硬件和操作系统（虚存技术）共同完成。 |

###### 存储器的带宽？

单位时间内，存储器存取的信息量。

###### 比较静态RAM和动态RAM？

| M1           | M2                                                 |
| ------------ | -------------------------------------------------- |
| 存储元的原理 | SRAM是双稳态触发器，DRAM是电容                     |
| 刷新         | SRAM只要不断点，信息就不会丢；DRAM需要刷新才能不丢 |
| 速度         | SRAM快，DRAM慢                                     |
| 功耗         | SRAM大，DRAM小                                     |
| 集成度       | SRAM低，DRAM高                                     |
| 价格         | 显然                                               |

###### 什么是刷新？

为了防止信息丢失，将DRAM存储元中的信息读出再写入的数据再生过程，称为刷新。

###### 比较DRAM的刷新方式？

| M1       | M2                                                           |
| -------- | ------------------------------------------------------------ |
| 集中刷新 | 在**最大刷新间隔**内，集中占用一段时间进行刷新。这段时间必须停止读写操作，即死区。 |
| 分散刷新 | 刷新安排在存取周期内，不存在死区。延长了存取周期，且刷新过于频繁而没有必要。 |
| 异步刷新 | 结合了集中刷新和分散刷新的特点，相对于分散刷新而言，**它降低了刷新次数；**相对于集中刷新，它缩短了死区。 |
| 透明刷新 | 在CPU不占用时刷新；使得刷新对CPU透明，但是电路复杂。         |

###### 以全相联映射为例，说明带Cache的系统中，如何读取数据？

CPU发出地址后，地址映射机构按照全相联映射方式将贮存地址和Cache中所有字块的字块标记进行比较，从而判断访问的内容所在块是否在Cache中。与此同时，也在访问主存。如果Cache有，则中断对主存的访问，将Cache中的字送入CPU；如果Cache没有，则继续访问主存，找到后，将此字传给CPU的同时，按全相联映射方式转换Cache地址块号，将主存块号送入Cache，如果Cache满，则执行替换算法（FIFO，LRU）和注意善后（写回，写直达）。

###### Cache映射有哪些方式？

| M1       | M2                                    | M3                                               |
| -------- | ------------------------------------- | ------------------------------------------------ |
| 直接映射 | 主存字块只能和**固定的**Cache块对应。 | 成本低，电路简单，但是利用率、命中率低。         |
| 全相联   | 主存字块可以和**任意的**Cache块对应。 | 成本高，电路复杂，利用率高。                     |
| 组相联   | 上述两种折中，**在组内构成全相联**。  | 集中上述优点。即：成本不高，电路简单，利用率高。 |

###### 什么是中断？

计算机执行程序时，出现**特殊情况或请求**时，**停止现行程序**运行，转向对这些情况或请求**的处理**。处理完毕**再返回间断处**，继续执行原程序。

###### ALU的组成？

加法器和寄存器。

###### 什么是寻址方式？

确定本条指令的数据地址和下一条指令的地址的方法。前者称为数据寻址，后者称为指令寻址。

###### 基址寻址和变址寻址的区别？

| M1     | M2                   | M3             |
| ------ | -------------------- | -------------- |
| 用途   | 为程序或数据分配空间 | 循环和数组问题 |
| 寄存器 | 不可变，操作系统定   | 可变，用户定   |
| 数据   | 可变                 | 不可变         |

###### CPU的结构和功能？

结构拍了照片。

CPU有6个功能：

| M1       | M2                       |
| -------- | ------------------------ |
| 指令控制 | 控制程序的顺序执行       |
| 操作控制 | 产生指令所需的微操作命令 |
| 时间控制 | 对各种操作进行时序控制   |
| 数据加工 | 进行算术逻辑运算         |
| 处理中断 | -                        |

CU的功能：取，分析，执行；处理输入输出、异常处理。

###### CPU响应中断的条件？

有中断请求；CPU开中断；在指令执行结束时。

###### 中断隐指令的作用？

关中断；保存PC；生成服务程序入口地址。

###### 单重中断和多重中断的服务程序的区别？

开中断的时间不同：单重中断在中断返回时开中断，多重中断在保护完现场后就开中断。

###### 多级结构存储器的一致性原则和包含性原则？

不同层级的存储器中，同一数据的值应当相同。内层存储器的数据一定包含在外层存储器中。

###### DMA接口的组成？

主存地址计数器，数据数量计数器，**控制状态逻辑**，DMA请求触发器，**DBR，中断机构**。

###### 说明DMA接口电路的工作过程？

首先CPU预处理：向DMA接口设置主存缓冲区地址、数据大小、传送方向，并启动外设。

数据传送：当外设准备完成，向DMA接口发出DMA请求，DMA接口再向CPU发出DMA请求，实现周期窃取；主存地址送总线，DMA接口将数据送数据总线，修改主存缓冲区地址和计数器，传送一字（CPU继续执行主程序）；若计数器不溢出，则继续发出DMA请求，重复上述过程；**若计数器溢出，则发出中断请求（一定是全都传送完成才发出中断请求，要不就变成程序中断方式了）。**

后处理：CPU响应中断请求，进入中断服务程序，进行校验（如果错转诊断程序），完成善后。

###### 为什么大量数据需要DMA方式？

程序中断方式速度慢，且容易丢失数据。

###### DMA方式能取代中断方式吗？

不能。

- DMA方式只能用于高速的简单数据传递，不能像中断那样**处理特殊情况**。
- DMA方式的后处理依赖于中断请求。

###### 什么是指令周期？指令周期是否有固定长度？

指令周期是CPU<u>取出并执行</u>一条指令的时间。

为了提升机器的运行效率，即便是在同步控制的机器中，不同长度的指令周期也是不一样长的。

###### 中断周期应该做什么？中断周期后是什么阶段？

中断周期应执行中断隐指令（关中断，存PC，转入口）;

中断周期结束就进入取指周期。

###### 节拍、机器周期、指令周期的关系？和微程序设计的关系？

- 指令周期是CPU<u>取出并执行</u>一条指令的时间。
- 机器周期是<u>在**同步控制**的机器中</u>，所有**指令执行**的一个基准时间，通常以访问一次存储器所需的时间作为一个机器周期。
- 时钟周期是计算机**主工作时钟**的周期，是计算机最基本的时钟单位，是主频的倒数。

每个机器周期包含若干时钟周期。可见，一条时钟周期对应执行一条微指令。一个执行机器周期运行一段微程序。

微指令由若干**同时执行的**微命令组成。也就是**同时执行**的微操作。

###### 组合逻辑控制器和微程序控制器的特点？

| M1               | 组合逻辑                   | 微程序               |
| ---------------- | -------------------------- | -------------------- |
| 产生微指令的方法 | 组合逻辑电路               | 存储逻辑             |
| 核心器件         | 由门电路构成的复杂树形网络 | 控存CROM             |
| 规整性           | 不规整                     | 规整                 |
| 可扩展性         | 不易扩展                   | 易扩展，常用于系列机 |
| 速度             | 快                         | 慢                   |

###### 比较程序和微程序？

| M1     | 微程序         | 程序         |
| ------ | -------------- | ------------ |
| 构成   | 微指令         | **机器指令** |
| 作用   | 表述机器指令   | 显然         |
| 对用户 | 不提供给用户   | 显然         |
| 编写者 | 计算机设计人员 | 一般程序员   |
| 存储   | CROM           | 主存         |

###### 简述微程序控制器的原理？

将**控制器需要的微操作命令**以微指令的方式写成微程序，放在CROM中。

CPU执行机器指令时，从CROM中取出微指令，解释后产生**控制器所需的位操作命令**序列。

- 先读取取指周期的微程序，用其中的微命令控制访存，读取机器指令，送入IR。
- 根据IR的操作码译码，通过微地址形成电路，产生微程序入口地址，送入uIR。
- 执行微程序。
- 回到（1）.

###### 微程序控制器如何根据操作码形成微程序入口地址？

机器指令到了IR后，其操作码部分作为微地址形成部件的输入，形成微指令地址。微地址形成部件是一个编码器，可用PROM实现。指令的操作码作为PROM的地址输入，该PROM的存储单元中就放着指令对应的微程序的入口地址。

###### 如何设计组合逻辑控制器？

- 拟定指令集；
- 确定CPU结构；
- 确定时序系统，拟定指令流程；
- 安排指令的微操作节拍；
- 列出微操作命令的时间表；
- 写出每一个微操作命令的逻辑表达式并化简；
- 画出逻辑电路图。

###### 如何设计微程序控制器？

- 拟定指令集；
- 确定CPU结构；
- 安排时序系统，拟定指令流程；
- 安排指令的微操作节拍；
- 确定微指令格式（包括编码方式和后续地址形成方式）；
- 编写微指令码点。

###### 操作控制字段的常见编码方式？

直接编码（直接控制）、字段直接编码、字段间接编码、混合编码。

###### 计算机硬件技术指标？

| M1       | M2                                               |
| -------- | ------------------------------------------------ |
| 机器字长 | -                                                |
| 存储性能 | 存储容量、数据通路带宽，吞吐量（取决于存取周期） |
| 运算速度 | 响应时间，主频，IPC，MIPS，FLOPS                 |

`【存储器】`存储器数据总线32位，存取周期200ns，求存储器的带宽？

```
每次传送32/8=4B，则200ns传送4B
则4B/200ns=20MB/s。
```

`【存储器】`求1100、1101的海明码。

```
2^r>=r+k+1，即2^r>=r+5，得r=3，需要3位，则得到形如CCXCXXX的校验形式。
其中，
D1->3,011.
D2->5,101.
D3->6,110.
D4->7,111.
则C1=D1^D2^D4,
C2=D1^D3^D4,
C3=D2^D3^D4.
当1100时，C1C2C3=011，当1101时,C1C2C3=100.（写这个连续XOR的时候不要硬算。要用偶校验的定义。）
即1100->0111100,1101->1010101.
```

`【存储器】`求海明码1100100，1100111是否出错。

```
根据上一题，有
CCXCXXX,
C1=D1^D2^D4,
C2=D1^D3^D4,
C3=D2^D3^D4.
则1100100的C1C2C3=110，原码为0100，错误情况（XOR结果（只要偶校验出错出错就置1，只要偶校验正确就置0））为A1A2A3=011，因此A3A2A1=110，（注意这里写A3A2A1便于进行带权展开）所以第6位错了。
则1100111的C1C2C3=110，原码为0111，错误情况为A1A2A3=111，即A3A2A1=111，所以第7位错了。
```

`【Cache】`块大小为4，共2K大小Cache，共256K的主存。

> 注意：一定要把主存和Cache的基本单位都换成“块”！

```
设计Cache内地址：共2^9个块，所以是9|2.
设计全相联映射的主存地址格式：主存块数量是2^18/块大小2^2=2^16.Cache中块数量是Cache容量2^11/块大小2^2=2^9.因此映射编号有2^16/2^9=2^7位，所以是7|9|2.
设计4路组相联的主存地址格式：Cache分组数是块数量0.5k/路数4=2^7，主存块数量是2^18/块大小2^2=2^16,则主存分区数量是主存块数量2^16/Cache分组数量2^7=2^9，则主存分区标记为9位。每个分区的大小是Cache分组数即2^7。因此是9|7|2，即分区|Cache组号|块内地址
设计全相联方式下的主存地址格式：主存块数是主存容量2^18/块大小2^2=2^16. 则格式为16|2.（主存块号+块内字号）
```

`【Cache】`Cache命中4800次，访问主存200次，Cache的周期是30ns，主存的周期是150ns.

```
求命中率？
Cache命中次数4800/Cache命中次数4800+主存次数200=48/50=0.96.
求该系统的平均访问时间？
命中率0.96*Cache周期30+非命中率0.04*主存周期150=34.8ns.
求系统的效率？
Cache周期/平均访问时间=30/34.8=0.862
性能提升？
即主存周期/平均访问时间=150/34.8=4.31
则提升了4.31-1=3.31倍。
```

`【Cache大字长】`主存1MB，直接映射，Cache16KB，存储字长32bits，块大小4，求ABCDEH地址在Cache中的哪个字节处？

> 注意：块的单位是字！因此，这里块大小为4，代表着一个块是4字大小，在本题中就是16B！

```
块大小为4个字，其中一个字32bits=4B，则一个块就是2^4B.
因此主存有2^20/2^4=2^16个块，Cache有2^14/2^4=2^10个块，所以主存分组为2^16/2^10=2^6组，即6位。
```

`【扩展操作码】`指令字长16位，操作数地址6位，如果定义13条2地址指令，问还能定义多少1地址指令？

```
2地址指令：0000 6 6 - 1100 6 6正好13条
则1地址可以从前面是1101开始，即1101 000000 6 一直到1111 111111 6. 6个全0到全1是2^6种（根据下面的地址规律），则其有高位01 10 11三种组合，所以是3*2^6种。
```

`【扩展操作码】`指令字长16位，操作数地址6位，一地址N种，零地址M种，求二地址最多多少种？如操作码变长呢？

```
不可以成为前缀。且二地址的发挥空间是16-6*2=4位，则其数量是2^4-M-N,14.
如果操作码变长，则是2^4-M/2^12-N/2^6,15.
```

###### 来自题目的注意

- 如何设计指令格式？根据操作的种类确定操作码长度；根据寻址特征的种类确定寻址特征字段长度；剩下的长度都留给形式地址。
- 直接寻址的范围是数据地址给出的；
- 一次间址的寻址范围是存储字长，多次间址的寻址范围是存储字长少一位（用于在存储器的这个单元中指出是否是多次间址）
- 立即数可以是无符号数或有符号数（补码表示）。例如6位，则无符号数是0-63，有符号数由于是补码表示，是-32到+31
- 相对寻址情况下，地址字段就是补码表示的有符号数，即-32到+31（假设此字段的长度为6）
- 相对寻址便于程序浮动。
- 可通过双字长指令提升寻址范围，或者通过和目标等长 的基址寄存器、变址寄存器，或者小于目标，但是可以移
- 位再与形式地址相加。

###### 来自题目的注意2

响应优先级是优先于处理优先级的。因为屏蔽字是进入某个中段源的中断周期后才设置的，但是大家实际上是先通过排队器来决定谁先进入针对其的中断周期。这个排队的过程由于在主程序，其屏蔽字为全0.

或者说，屏蔽字是为了防止被多重中断而使用的。因为在主程序排队器阶段，屏蔽字全0，大家平等。

###### 地址规律

可以标出当前的二进制位是第几位，从1开始数。

**例如当前编号是11，则这些位全1就是2^11-1，这一位就是2^(11-1).**

想要多少种不同的编码，例如想要2^11种不同的编码，就让他是**11位的从全0到全1.**

## Chap.1 计算机系统概论

#### 现代计算机的硬件框图？

#### 冯诺伊曼计算机的特点

冯机的主要思想是“存储程序”。

| 方面           | 概述                                                       |
| -------------- | ---------------------------------------------------------- |
| 组成部分       | 运算器，存储器，控制器，输入输出设备                       |
| 存储程序       | 指令和数据同等地位存储在存储器中；指令是顺序存放而构成程序 |
| 二进制化       | 指令和数据都是二进制表示                                   |
| 指令格式       | 由地址码和操作码构成                                       |
| 以运算器为中心 | 输入输出绕不开运算器                                       |

现代计算机：尝试绕过运算器进行IO。

#### 计算机的工作步骤

1. 把程序和数据装入主存；
2. 从程序的起始地址运行程序；
3. 取出第一条指令，经过分析、执行，使计算机各部件协同运行，并得到下一条指令地址；
4. 用新得到的地址继续执行程序，每条指令重复上述过程，直到程序结束。

#### 计算机如何区分指令和数据

通过地址来源区分：如果是根据PC取出则是指令，如果是根据操作地址取出就是数据；通过时序阶段区分：如果是取指阶段取出就是指令，如果是执行阶段取出就是数据；通过取出后的保存区分：如果是保存在IR就是指令，如果保存在诸如ACC，MQ，X等地方就是数据。

#### 计算机的性能指标

###### 机器字长

计算机进行一次整数运算，所能处理的二进制位数。一般是8的整数倍。

CPU内的寄存器一般采用这个子长，它反映了计算机运算的**精度**。

###### 数据通路带宽

数据总线可以并行传输数据的位数。

###### 主频

CPU时钟周期的倒数。时钟周期是CPU最小的时序单位。

###### CPI

Clock cycle Per Instruction，即每个指令需要多少个时钟周期。

###### MIPS

Million Instructions Per Second，百万指令/s。

###### FLOPS

Floating-point Operations Per Second，浮点运算次数/s.

#### 其他要点

###### 主频高的CPU一定快吗？

还要看架构，机器字长、CPI、MIPS等。因为主频和CPU速度没有直接关系。

###### 三种字长

| “字长”   | 解释                                 |
| -------- | ------------------------------------ |
| 机器字长 | 计算机进行整数运算处理的二进制的位数 |
| 存储字长 | 一个**存储单元**存储二进制代码的长度 |
| 指令字长 | 指令的二进制长度                     |

## Chap.4 存储器

#### 存储器的层次结构

**即Cache-主存层次和主存、辅存层次。**前者用于提升速度，CPU访存速度加快，同时价格接近主存（比Cache速度的存储器低多了）；后者用于扩容，CPU获得了辅存大小、主存速度的空间，同样是速度快，价格低。

综合上述两个层级，可以发现它们的目的是相同的。**即：从整体上看，获得了一个价格低、速度快、容量大的存储系统。**

此层次完全由硬件进行信息调度，对程序员透明。

#### 存储器的性能指标

1. 存储容量。
2. 单位成本。例如每位的价格。
3. 存储速度。见下表。

| 概念     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| 存取周期 | **进行一次完整操作所需的完整时间。或：两次独立访存操作之间最小的时间间隔。**存取周期包括存取时间+恢复时间。因此存取周期会比存取时间长。（破坏性读出存储器需要在存取时间后立即恢复数据。这两个时间加起来就是存取周期。） |
| 带宽     | 即传输数据率。                                               |

#### SRAM、DRAM

###### 存储元、存储单元和存储体

存储元负责存储单个比特。存储单元是多个这种存储比特的存储元的集合，负责存储字节、字。存储体是多个存储单元构成的。

###### SRAM的特点

利用双稳态触发器（六管MOS）来存储。因此其支持非破坏性读出，但是断电易失。因为触发器只要带电就可以保证数据一直在，所以称为Static RAM.

**SRAM的速度快，用作Cache。**

###### DRAM的特点

DRAM**<u>采用存储元电路上的栅极电容</u>**存储比特，因此需要刷新。因为只要不刷新，**过1-2ms后**数据就会消失，所以相对于稳定的SRAM，给他起名Dynamic RAM.

**DRAM的速度比SRAM慢，因此用作主存。**

DRAM采用地址复用，访存时先读行地址，再读列地址。

#### DRAM的刷新

###### 三种刷新

| 刷新方式 | 刷新对象 | 时机                                  | 特点                       |
| -------- | -------- | ------------------------------------- | -------------------------- |
| 集中刷新 | 整个DRAM | 刷新周期到来时                        | 有死区，不影响存取周期     |
| 分散刷新 | 某一行   | 每个读写周期的后段                    | 无死区，但是存取周期变长   |
| 异步刷新 | 某一行   | 刷新周期/行数作为周期，这个周期到来时 | 缩短了死区，不影响存取周期 |

集中刷新：每次刷新周期到来时，不允许访存，直接对整个DRAM进行刷新。

分散刷新：把对某一行的刷新操作放到存取周期内进行。霸占了存取周期很多时间。这样极大延长了存取周期，效率不高。

异步刷新：不再霸占存取周期时间了，但是每过“刷新周期/行数”时间就得进入一小段死区。

###### 什么是刷新

刷新是无需片选的，针对某一行的读写操作。它在无需片选（即可以把所有存储体都选上）的情况下，拿着某一行的地址，先读出来，再写回去。

#### 大端存储和小端存储

所谓，即：存储字仍然是从低到高排列，但是这个字内的字节存储如果是大端存储就是正常顺序（即小地址存编号小的字节，大地址存编号较大的字节），如果是小端存储就是逆序排列。如果这些内容超过了一个字长，则在下一个字内部也是这么排。

#### 边界对齐存储

###### 如何对齐？

例如顺序地往次存储器里面放数据，如果不对齐那就是按顺序只要有空就把它填满，如果这一行（即这一个字）没有空间了，就另起一行把剩下的部分写进去即可。如果对齐，那就是如果这个字没有空间了，就直接另起一行写入。（具体写到头部还是尾部要看大端对齐还是小端对齐。）

> 即：所谓对齐就是一看没空了就另起一行。因为另起一行一定是有空的。

###### 好处

以存储字长为4B的机器为例，边界对齐能保证半字一定是2的整数倍，字一定是4的整数倍，这样能使得读取长度<=字长的**数据就<u>一次性</u>读出。能够提升读取速度，且做到完全相同的读取速度，提升效率，且能适应指令流水。**

缺点是它比较浪费空间。这是一种空间换时间的思想。

###### 如果不边界对齐会怎么样

即便读取<字长长度的数据，仍然可能需要2次访存。

#### 多模块存储器

**为提升访存速度**，提出多模块存储器概念。多模块存储器就是像拆电脑拆出来的内存条，其中由多个芯片构成！

###### 单体多字存储器

这种存储器由单个存储体构成，区别只是在于这种存储器可以一次性读出多个连续的字。

这对于连续存放的程序很有用，但是不连续的程序就没有意义。

###### 多体并行存储器

这种存储器由多个存储体构成，根据编址方式分为高位交叉和低位交叉编址。

`高位交叉编址` 把高位作为存储体编号。因此，程序仍然连续存放，各个存储器一般无法并行工作，作用不大。因此，这种存储器仍然称为顺序存储器，就是因为程序仍然顺序存放。**各个存储体无法交叉工作。**

`低位交叉编址` 它真正实现了存储体的交叉寻址、并行工作。它把低位作为存储体编号。因此可以实现流水线读取。

###### 多体并行低位交叉存储器的流水线读取

设总线传输延时r，整个多体并行低位交叉存储器的存取周期为T，设要读取m个字，则需要(m-1)r+T时间。

**这个过程中，每个模块的启动间隔是总线传输延时r。**

#### Cache 高速缓冲存储器

Cache是SRAM，速度非常快，能与CPU速度匹配。因此放在CPU和主存之间。

###### 程序访问局部性原理

时间局部性：由于存在循环，所以当前用到的内容很可能一会也用到。

空间局部性：由于程序顺序存放，所以～

###### CPU访问主存流程（Cache存在的情况下）

读：先找Cache，或者同时找Cache和主存。如果Cache里有，就用Cache的（如果也同时找了主存，则同时中断对主存的查找）；如果Cache里没有，就去主存找，或继续主存的查找。找到后，把找到的数据**<u>所在的块</u>**也写入Cache。如果Cache对应**块**位置满，则执行替换算法（LRU、FIFO、RAND算法）。

写：为防止内容不一致，使用全写法和写回法。

###### 注意访问单位

CPU对Cache的访问是**字为单位**，Cache和主存之间的访问是**块为单位**。

###### *命中率和平均访问时间计算

PDF P136.

###### *Cache主存地址块映射

| 映射       | 解释                                                         | 块标记             |
| ---------- | ------------------------------------------------------------ | ------------------ |
| 直接映射   | 直接把主存划分成若干Cache大小的区域，每个区域中的块在这个区域内第几块，其映射到Cache内就第几块 | 主存组号+组内块号  |
| 全相联映射 | 主存内任意的块可以映射到Cache的任意的块                      | 主存块号           |
| 组相联映射 | 主存分成若干区域。每个区域内的第i块只能放在Cache的第i组内。  | 主存区号+Cache组号 |



#### 其他要点

###### 存储器的分类

随机存储器RAM、只读存储器ROM、串行访问存储器。

或者主存、缓存、Cache。

###### FlashMemory

闪存是基于EPROM的，所以实际上是一种ROM。

它像ROM一样，可以不带电保存数据，同时又能具有比ROM高得多的存取速度。

###### Cache块大小和命中率、效率的关系

不是。虽然Cache块越大，局部性原理越透彻，能保证把更大的局部空间进行加速，但是Cache块大了，一次从主存放入Cache的数据过多，速度较慢；并且Cache块大了就意味着Cache块少了，命中率下降。

###### 提高访存速度的措施

1. 利用层次结构（Cache-主存/主存-辅存）
2. 调整主存结构（低位交叉高位交叉）
3. 采用高速器件

## Chap.5 IO系统

#### IO接口的结构和功能

###### 结构

| 组成                   | 解释                                             |
| ---------------------- | ------------------------------------------------ |
| 数据缓冲寄存器（DBR）  | CPU对外设的读写实际上就是对DBR的读写。           |
| 控制逻辑电路           | -                                                |
| 设备选择电路           | 设备要知道这个地址是否在访问自己。               |
| 命令译码器和命令寄存器 | 接收CPU来的命令并执行                            |
| 设备状态标记           | CPU查询时可以得知情况                            |
| 内部接口               | 与系统总线（即CPU和主存）相连。并行传输。        |
| 外部接口               | 与外设相连。可能是串行的，因此需要串并转换功能。 |

###### 功能

接口主机和外设的交接界面。主机和外设在工作方式、速率上有较大差别，于是接口就出来调和它们了：在各个外设和主机之间传输数据时进行协调的结构。协调包括传输速率、电平和格式转换等。

| 功能                     | 解释                                               |
| ------------------------ | -------------------------------------------------- |
| 主机和外设的通信联络控制 | 协调它们的时序和速率。                             |
| 地址译码和设备选择       | 设备要知道这个地址是否在访问自己。                 |
| 数据缓冲                 | 协调它们的时序和速率。                             |
| 格式转换                 | 转换信号的格式。例如模拟-数字转换、串行-并行转换。 |
| 传送控制命令和状态信息   | CPU给外设命令；外设给CPU状态。                     |

#### IO端口

端口是接口中的寄存器，它只具有寄存器的功能。

**端口+控制功能=接口。**

#### IO端口的编址方式

###### IO端口的分类

数据端口（即数据寄存器，DBR）——可读写的端口。

状态端口（即状态寄存器）——只读端口。

控制端口——只写端口。

###### 统一编址（存储器映射方式）

把这种寄存器当作内存空间进行编址。

好处：更方便，不需要单独的IO指令。

缺点：速度慢，占用地址空间。

###### 独立编址（IO映射方式）

这种寄存器的地址独立于内存地址空间。

坏处：**需要有专门的**IO指令来访问端口。

#### 程序查询方式

###### 接口设计

主要由DBR、状态端口、命令端口构成。

###### 流程

1. CPU设置传送参数，发出命令，启动设备；
2. CPU不断读取状态段口，直到设备准备就绪；
3. 传送一次数据，并让计数器-1，地址参数+1；
4. 如果计数器非0，则跳转到2.

###### 评价

CPU和外设串行工作，必须中止现有程序并插入一段新程序，CPU原地踏步。且不支持多个外设同时通信。

#### 程序中断方式

和查询方式的区别在于：不是CPU去主动查询外设状态了，而是外设自己准备，等着准备好了就告知CPU，请求CPU为自己服务。CPU视当前情况，可以进入中断服务程序为其服务。

###### 外中断和内中断

即外设引起的中断和电脑自己产生的中断（例如算术溢出、软件主动要求中断等）。内中断不可被屏蔽、不可被关中断。

###### 中断请求触发器INTR

此触发器可以在CPU里，也可以分散在各个中断源中。每个中断源占一位。

###### 中断判优

用于同时有多个中断请求，CPU去选择一个响应。**硬件实现：排队器，可以集中在CPU，也可以分散在各个设备上。软件实现：中断查询程序。**

###### 中断响应

CPU响应中断的条件：中断比当前中断优先级高；开中断；当前指令执行完毕。

###### 中断隐指令

CPU响应中断后，转到中断服务程序。这个过程由硬件实现，所以不是指令实现。但是像一条指令，所以称中断隐指令。

| 操作                     | 解释                                             |
| ------------------------ | ------------------------------------------------ |
| 关中断                   | 防止后续保存断点的操作被打扰                     |
| 保存程序断点             | 保存PC的值（入栈），便于一会赋值                 |
| 生成中断服务程序入口地址 | 通过软件查询法或硬件向量法生成入口地址，赋值给PC |

###### 中断向量和中断向量地址

中断向量是中断服务程序入口地址。每个外设都对应一个中断向量，因为它们的功能各不相同。CPU维护一个中断向量表来作这一点。

中断向量地址是中断服务程序入口地址的地址。

`硬件向量法` 硬件产生此外设对应的中断类型号，此中断类型号指出了CPU维护的向量表中的中断向量地址。

`软件查询法` 编程实现～。

###### 保护现场和保存断点的区别

前者是包括保存中断屏蔽字（保存屏蔽字是因为一会要设置屏蔽字）、CPU某些寄存器、程序状态字；后者只是PC值而以（提供中断返回地址罢了）。

###### 中断处理

| 操作             | 解释                                       |
| ---------------- | ------------------------------------------ |
| 执行中断隐指令   | 包括关中断、保存断点、生成服务程序入口地址 |
| 保护现场         | ～～～                                     |
| 置屏蔽字         | ～～                                       |
| 开中断           | ～                                         |
| 执行中断服务程序 |                                            |
| 关中断           | ～                                         |
| 恢复屏蔽字       | ～～                                       |
| 恢复现场         | ～～～                                     |

###### 中断返回

| 操作     | 解释 |
| -------- | ---- |
| 开中断   | ～   |
| 中断返回 | ～   |

###### 中断屏蔽触发器

如果是1则代表屏蔽它。

#### DMA方式

###### 特点

1. 传送服务完全由**接口**电路完成（计数、地址确定等），不用CPU去管。
2. 主存应设置缓冲区，以及时接收和供给数据。
3. 中断请求只用于应对异常情况。

###### DMA接口的结构和功能

1. 接收外设的DMA请求，并代替外设向CPU发出DMA请求。
2. 控制总线，传输数据。
3. 修改计数器，更新主存地址。
4. DMA结束时提出中断请求。

| 结构                           | 解释                                    |
| ------------------------------ | --------------------------------------- |
| 主存地址计数器、传送长度计数器 | 修改计数器，更新主存地址。              |
| DBR                            | -                                       |
| DMA请求触发器                  | 表示DMA请求                             |
| 控制/状态逻辑                  | 指定传送方向，对CPU响应信号进行协调同步 |
| 中断机构                       | **DMA传送完成，提出中断**               |

###### DMA传送方式——周期挪用

- 如果CPU当前没在访存，则DMA直接霸占。
- 如果CPU正在访存，则CPU存取周期结束后就让出总线控制权。
- 如果CPU和DMA同时想要访存，则让给DMA一个或几个访存周期。

###### DMA传送过程

| 过程     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| 预处理   | **即CPU完成一些必要工作和DMA请求的发出**。首先，CPU发出一些IO指令，测试设备状态；然后，设置有关端口的初值，设置传送方向，启动设备。CPU继续执行原有程序，当DMA设备准备就绪，就给DMA接口发送DMA请求，DMA接口再给CPU发DMA请求。 |
| 数据传送 | 完全由DMA接口控制数据的传送。                                |
| 后处理   | **即DMA接口发出中断请求，由服务程序进行结束处理。**这里，中断服务程序要做的包括校验数据（如果出错则进入诊断程序）、是否继续使用DMA等。 |



#### 其他要点

###### 接口的分类

| 接口分类标准                        | 解释                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| 串行和并行接口                      | 外接口支持的类型。（注意，不是内接口。因为内接口永远是并行。） |
| 程序查询接口、程序中断接口、DMA接口 | **按主机访问IO设备的控制方式。**                             |
| 可编程、不可编程接口                | 灵活性                                                       |

###### DMA其他的传送方式

停止CPU访问数据总线——CPU直接停止程序，保持现有状态。

DMA和CPU交替访问——对数据总线进行时分多路复用TDM。

###### DMA方式VS程序中断方式

1. DMA方式只有预处理和后处理占用CPU资源，DMA传输只需要DMA接口的控制。
2. DMA请求可以在任何机器周期被响应，只要CPU不占用总线就能响应。
3. DMA请求的优先级高于中断请求。
4. DMA方式依赖于中断方式，因为需要提出中断请求以结束DMA传送，并进行后处理。

## Chap.6 运算方法

#### 定点数原反补移码

<u>**注意，纯小数的最低位是2^(-n)，但是整数的最高位是2^(n-1).**</u>

| 码             | 表示范围                                                     |
| -------------- | ------------------------------------------------------------ |
| 无符号数纯小数 | 表示格式是0.XXXXXX，其中一位用来做符号位，只有n位有效，所以是[0,1-2^(-n)].（类比原码纯小数。） |
| 无符号数整数   | 表示格式是XXXXXX，不存在符号位，全n+1位都有效，所以是[0,2^(n+1)-1] |
| 原码纯小数     | n+1位字长，则小数点后面有n位，则最低位表示的数字是2^(-n)，则小数点后面全1就是小数点后面全0再减去2^(-n)，即1-2^(-n)。又因为符号位单独作用，所以存在正0和负0问题，所以最终是[-(1-2^(-n)),1-2^(-n)]. |
| 原码纯整数     | n+1位字长，则除去符号位有n位，最高位代表2^(n-1)，则得到全1应该用全0，即2^(n)减去1（最低位1），即2^n-1.又因为符号位单独作用，所以存在正0和负0问题，所以最终是[-(2^n-1),2^n-1] |
| 反码纯小数     | 只是取反了，和原码没有区别，仍然存在正0负0，仍然是[-(1-2^(-n)),1-2^(-n)]. |
| 反码纯整数     | 只是取反了，和原码没有区别，仍然存在正0负0，仍然是[-(2^n-1),2^n-1] |
| 补码纯小数     | 去掉了负0的问题，匀给了-1，即[-1,2^n-1]                      |
| 补码纯整数     | 去掉了负0的问题，匀给了-2^n，即[-2^n,2^n-1]                  |
| 移码纯小数     | **<u>小数不存在移码。</u>**                                  |
| 移码纯整数     | 只是补码符号位取反，和补码没有区别，即不存在负0问题，即[-2^n,2^n-1] |

注意，移码只是以2^n平移了真值。因此，移码大，真值就大。（如果把整个码都看成无符号数）

#### 定点数溢出

###### 上溢出和下溢出

例如定点小数的表示范围是[-(1-2^(-n)),1-2^(-n)]，则如果得出>=1的结果，超出了上述表示区间上限，称为上溢出；得出<=-1的结果，超出了上述表示区间下限，称为下溢出。

###### 溢出处理

对于定点小数，只要溢出就是出错。（但是浮点小数不算出错。）

###### 溢出出现的前提

溢出**只有在两个同符号数运算时**发生。

###### 溢出的判断方式

1. 单符号位判断：改变即溢出
2. 双符号位判断：相互不同即溢出
3. **符号位进位和数据位进位判断：相互不同即溢出**

#### 浮点数溢出

###### 两侧溢出

> 浮点数溢出和定点数溢出的最大不同在于：浮点数要分成正、负两种上溢和下溢。它的溢出图是两段式的。

###### 溢出处理

尾数溢出和阶码溢出：**如果尾数溢出，则没有问题，可以通过右规解决；**如果阶码溢出，那**是真溢出了**（如果大于最大，则机器停机；如果小于最小，则按机器0处理）。

#### 浮点数规格化

###### 从提升精度角度考虑规格化的定义

为了提升浮点数的精度（尾数有效位数越多，精度越大），要求**尾数最高位必须是有效值**。所谓有效值，就是1.（补码看情况也许为0.）

###### 左规

> 左规只会出现在浮点运算完成后。

把运算完成后，不规格的数字变成规格的即可。

> 可能需要左规多次。

###### 右规

> 右规只会出现在浮点运算溢出时。

浮点运算溢出，符号位不相同了，但是最高符号位表示真的符号位，所以右规即可。

> 如果右规，**必然**只需要右规一次。

#### 浮点运算的一般步骤

| 步骤     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| 对阶     | 先求阶差，然后小阶看大阶（右移会影响精度）                   |
| 尾数求和 | 对尾数进行定点纯小数运算                                     |
| 规格化   | 尾数溢出则右规（右移会影响精度），尾数过小则左规             |
| 舍入     | 由于右移会影响精度，如果把1移没了，则在移后的最低位+1（0舍1入法）（可能又得右规）；或者直接让最低位=1（恒置1法）. |
| 溢出判断 | 根据浮点数的溢出定义进行判断。如果阶码上溢出，则溢出了；如果阶码下溢出，则按机器0处理。（此是尾数是必然不可能溢出的，因为已经右规和舍入完成） |

#### 74LS181 算术逻辑单元

可实现16种逻辑运算、16种算术运算。其中，加法器是并行加法器。

#### 海明码

n+k<=2^k-1.

###### 构造校验后的数据

1. 确定位数：取上述k。
2. 确定校验位分布：取2^i-1.因此，分别在第1，2，4，8，...位上。
3. 确定分组：例如原数据第3位，3拆成011，则由校验位1和校验位2检验（因为第1位和第2位是1）。
4. 算出各校验位的值：根据上述分组，可以知道原数据每一位由哪些校验位。我们反过来看，对于每个校验位，它校验了哪些数据位，然后把它校验的这些数据位XOR（也就是根据偶校验的规则对于它的数据进行校验），就得到这个校验位的值。

###### 检验是否出错

同上述步骤4，找出每个校验位对应的校验对象，做XOR，看结果是否为0.（即看它们是否符合**偶**校验的规则。）

例如，最终把各个校验位和它们校验对象XOR得出的结构按从高到低位排列，例如如果是000则没错，例如如果是011则原数据第三位错了。

###### 注意

数据的最低位都是“第一位”，而不是“第0位”。

#### 其他要点

| 算法         | 加法次数和移位次数的关系                         |
| ------------ | ------------------------------------------------ |
| 原码一位乘法 | 最后移位后一定不需要加法了                       |
| 校正法       | 最后移位后如果需要校正还需要加X的反补码          |
| Booth算法    | 最后移位后必然需要加法，加X的反补码，X的补码或+0 |



###### 校正法

- 无论被乘数的符号如何，就直接当成原码乘法算。最后看如果乘数为正，则不管；如果乘数为负，则要加X寄存器的数的原码的相反数的补码（即[-X]补）校正。
- 如果一正一负相乘，则把负的那个当作被乘数，这样可以不考虑校正。因为算法与被乘数无关。
- 补码乘法要采用算术移位，因为符号参与运算。
- X和ACC都采用双符号位（高符号位用于计算符号，低符号位兜进位），MQ仍然是无符号数。
- 注意双符号位11和11相加，如果低位没有进位则得10.
- 为什么要对乘数的正负进行讨论？因为MQ不存在符号位，这会出现问题；而ACC自带符号位，所以符号位没有问题。

###### Booth算法

- 仍然采用校正思想，每次都进行校正，因此仍然采用X寄存器内的反补码和补码。每一轮加的就是X寄存器内的反补码和补码。
- 每一轮通过“辅助位-MQ最低位”的值来判断。如果为1则+X寄存器补码，如果为-1则+X寄存器反补码。如果为0则什么也不做。
- MQ增加了两位，分别是符号位和附加位，分别在原n位的MQ的基础上，在最高为左边和最低位右边添加，从而成为n+2位MQ的新的最高位和最低位。
- ACC和X寄存器仍然采用双符号位，算术移位。
- 仍然按原码一位乘法判断结束，即原来MQ中的值都被移走了（这里是都被移动到附加位及其右边去了）。区别在于，当完成原码一位乘法中的最后一次移位后，还需要再进行一次加法。

###### 计算机为什么不能精确表示数字

对于整数，只要字长足够就可以表示；但是小数不可以。因为小数都是以1/2^n的加法组合进行表示的。显然0.1无法被表示。

###### 字长相同的情况下，定点和浮点表示的优劣

定点利用了全部字长来表示这个小数，精度很高；

浮点数划分了一部分作为阶码，扩充了表示范围，但是相应地，尾数变短了，精度下降。

###### 为什么用IEEE 754移码表示阶码，用原码表示尾数

1. 因为移码方便比较大小，它只是平移了原码。
2. 因为n+1位的移码表示范围还是[-(2^n-1),2^n-1]，加上2^n就是[1,2^(n+1)-1]。如果判断下溢，则判断阶码是否为0，就知道是否下溢了。

###### 相同位数的定点数和浮点数，表示的数据个数是一样多的

因为编码的状态个数**完全相同**。

它们的区别只是精度上的区别。浮点数用精度换取了范围。

## Chap.7指令系统

#### 指令的一般格式

| 指令   | 格式               | 例                                                           |
| ------ | ------------------ | ------------------------------------------------------------ |
| 零地址 | OP                 | 停机指令（无需操作数）；栈运算（从栈顶弹出操作数，隐含操作数） |
| 一地址 | OP\|A              | 只有目的操作数或隐含另一个操作数                             |
| 二地址 | OP\|A1\|A2         | 俩操作数                                                     |
| 三地址 | OP\|A1\|A2\|A3     | 俩操作数，A3是结果                                           |
| 四地址 | OP\|A1\|A2\|A3\|A4 | 俩操作数，A3是结果，A4是下一条指令地址                       |

###### 扩展操作码

> 定长操作码的坏处：不能兼容多种指令格式。每条指令的操作码长度是固定的。
>
> <u>为了丰富指令格式，引入扩展操作码。</u>

扩展操作码的作用在于在指令字长一定的情况下，分出各种不同地址数量的指令。例如零地址、一地址、……。

基本原理就是把不属于这一类指令的字段用1填充，用以区分。属于其前缀的指令就不能采用全1操作码，以防冲突。

例如如果希望每种指令都是15种，字长16位，则：

| 指令格式 | 例                                                       |
| -------- | -------------------------------------------------------- |
| 三地址   | 0000 XXXX XXXX XXXX-1110 XXXX XXXX XXXX，15条            |
| 二地址   | 1111 0000 XXXX XXXX-1111 1110 XXXX XXXX，15条            |
| 零地址   | 1111 1111 1111 0000-1111 1111 1111 1111，**<u>16条</u>** |

注意，零地址会多一条。

#### 寻址方式

###### 有效地址和形式地址

写在地址码部分的地址可能不是真实地址。因此，可以通过寻址方式，计算形式地址得出有效地址。有效地址才是真实地址。

###### 主要寻址方式

指令寻址和数据寻址。

指令寻址包括顺序寻址和跳跃寻址，前者是PC+1，后者是JMP。

数据寻址即通过地址码计算出有效地址。

###### 数据寻址

| 数据寻址方式   | 解释                                                         |
| -------------- | ------------------------------------------------------------ |
| 隐含寻址       | 例如加法之前先把数存到ACC里面                                |
| 立即数寻址     | 地址码**就是操作数本身**                                     |
| 寄存器寻址     | 地址码字段存放的是寄存器的名称。操作数在寄存器里。           |
| 寄存器间接寻址 | <u>**加速版本的间址**</u>。即：把有效地只放在某寄存器中，访问此寄存器即可找到真实地址。<u>**地址码字段存放的是寄存器的名称。**</u> |
| 相对寻址       | PC内容加地址码字段就是有效地址。                             |
| 基址寻址       | 扩大寻址范围，有利于多道程序和浮动程序的设计。基址寄存器内容由操作系统决定。使用哪个作为基址寄存器可由用户决定。 |
| 变址寻址       | 扩大寻址范围，便于数组处理和循环程序。                       |
| 堆栈寻址       | **CPU内有特定的栈顶寄存器SP指出堆栈读写单元的地址。**        |

###### 基址寻址和变址寻址的区别

> 两者的区别是：基址寻址的地址码是可变的，意思是基址是首地址，地址码是机动指针；变址寻址的操作码是不可变的，意思是操作码是首地址，变址是机动指针。

#### 其他要点

###### 指令长度

指令长度可以等于机器字长（这样操作比较简便），也可以是单字长指令（等于机器字长），半字长指令、双字长指令。

## Chap.8,9,10 CPU结构和功能、CU

#### CPU的结构

###### ALU

| 结构                                              | 功能                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| 算术逻辑单元（ALU）                               | 运算                                                         |
| 移位器                                            | -                                                            |
| 暂存寄存器                                        | 暂存从主存读取的内容。（一般不可直接放在某些寄存器中，怕破坏其内容） |
| 累加寄存器（ACC）                                 | 1.暂存ALU运算的信息；2.作为加法运算的一个操作数。            |
| 通用寄存器组（X等）                               | 存放ALU运算信息以及作为操作数；                              |
| 程序状态字寄存器（例如溢出标识OF，符号标识SF...） | 状态信息                                                     |
| 计数器                                            | 控制诸如乘法运算等进程                                       |

###### CU

| 结构                    | 功能                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 程序计数器（PC）        | 下一条指令地址                                               |
| 指令寄存器（IR）        | 当前正在执行的指令本身                                       |
| 指令译码器              | 翻译操作数字段，从而提供操作信号                             |
| 存储器地址寄存器（MAR） | -                                                            |
| 存储器数据寄存器（MDR） | -                                                            |
| 时序系统                | 由统一的时钟控制的系统，用于产生各种时序信号                 |
| 微操作信号发生器        | 根据CLK、IR、状态信息，产生控制信号，分为组合逻辑型和微程序型 |

#### 指令周期

###### 指令周期、机器周期和节拍（时钟周期）

CPU完成一条指令的时间。包括取指、间址、中断、执行。其中，上述四个小周期称为机器周期。每个机器周期又分为若干时钟周期。时钟周期是电脑执行操作的最小时间单位，又称节拍。

**取指、间址、中断、执行周期都需要访存**。即取指令、取有效地址、取操作数、保护断点。

这四个周期都通过触发器**表示**出来。处在某一周期，则此周期对应的触发器的值为1.

#### 微程序控制器的基本概念

<u>我的CPU实验中的二进制串是微指令，其中每一位都是微命令。微地址就是我的PC中从1开始加。微周期就是我按CP之间的间隔。</u>

| “微”   | 解释                                    |
| ------ | --------------------------------------- |
| 微操作 | 计算机中最小的操作单位。                |
| 微命令 | 一条微操作实现一条微命令。              |
| 微指令 | 一条微指令包含若干微命令。              |
| 微周期 | 取微指令的时间+执行其所有微操作的时间。 |
| 微地址 | 控存中存放微指令的地址。                |
| 微程序 | 一个机器指令由一段微程序实现。          |

#### 微指令的格式

###### 水平型微指令

操作控制字段+顺序控制字段。即操作码+下地址。操作码就是我那些二进制串，**下地址用于产生下一条微指令的地址。**

###### 微指令的直接编码方式，字段直接编码方式和字段间接编码方式

直接编码就是我做实验用的那种：每一位代表一个微操作（微命令）是否有效。

字段直接编码方式就是把互斥的微命令分到同一组，作为一个字段，然后对其进行编码，然后读取的时候分别对这些字段译码。要注意字段不能过长否则译码过慢，而且要留出全0作为“什么也不执行”。

字段的一些微命令需要由其他字段来解释。这削弱了并行性。

###### 垂直型微指令

每条微指令只能对应一个微操作。这就类似于机器指令的结构了。但是效率过低。

###### 混合型微指令

在垂直型微指令的基础上，加上若干并行操作。

###### 

#### 微地址的形成方式

- 下地址直接给出；（断定方式）
- 机器指令译码给出；
- uPC+1给出；
- 外界标识位输入决定；
- 网络测试给出；
- 硬件直接给出；（例如电脑开机的第一条地址，就是硬件直接给出。它就是0号微地址，也就是取指周期的微程序入口）

#### 其他要点

###### 为什么中断周期的进栈是SP-1

因为计算机中的栈是向低地址增大。因此栈扩大，则SP得-1.

###### 指令的单周期、多周期、流水线方案

单周期就是定长周期，所有指令不管是否复杂，其指令周期长度都和所有指令中最花时间的那个指令一样长。

多周期就是变长周期，所有指令都可以有适合自己的指令周期长度，即需要多少时钟周期，就分配多少时钟周期。

流水线方案即让指令尽量并行执行，它在**每个时钟周期**启动一个指令周期，期望每个时钟周期都能完成一个指令周期。让不同的指令同时在自己的指令周期中，但是它们所处的**阶段不同**。

###### 一般认为取指周期等于机器周期

机器周期是一个基准时间，一般等于CPU访问一次主存的最段时间。因此，如果存储字长=指令字长，则取指周期等于机器周期。

###### CU的输入信号

1. 指令译码器的指令信息
2. CLOCK
3. 程序状态信息

###### CPU控制方式

| 控制方式     | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| 同步控制方式 | 有统一的时钟信号：以最慢的指令作为基准。以后就统一按这个信号作为基本单位。控制单元简单，但是执行慢。 |
| 异步控制方式 | 没有统一的信号，合干戈的。控制单元复杂，但是执行块。         |
| 联合控制方式 | 大部分指令采用同步控制，少部分指令采用异步控制。             |

###### 微程序控制器的工作流程（关于取指周期微程序）

- 将公共的取指微程序入口送入CMAR，一般这个地址都是0号单元。执行公共的取指微程序。
- 取到指令后，通过微地址形成部件形成此指令的微程序的入口地址，送入CMAR。
- 执行此微程序。
- 回到1.

除了取指周期微程序，还可以加入其它机器周期的微程序。

因此，如果机器的指令集为n，那么至少有n+1段微程序。

